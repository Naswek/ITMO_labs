### 1. JSF: Базовые понятия, характеристика технологии, реализуемая модель и прочие общие моменты:
- JSF — фреймворк для разработки вебприложений.
- Входит в состав платформы Java EE.
- Основан на использовании компонентов.
- Для отображения данных используются JSP или XML-шаблоны (facelets).
------------------

**Достоинства**
- Чёткое разделение бизнес-логики и интерфейса(фреймворк реализует шаблон MVC).
- Управление обменом данными на уровне компонент.
- Простая работа с событиями на стороне сервера.
- Доступность нескольких реализаций от различных компаний-разработчиков.
- Расширяемость (можно использовать дополнительные наборы компонентов).
- Широкая поддержка со стороны интегрированных средств разработки (IDE)
------------------

**Недостатки**
- Высокоуровневый фреймворк — сложно реализовывать не предусмотренную авторами функциональность.
- Сложность разработки собственных компонентов.
- Сложности с обработкой GET-запросов(устранены в JSF 2.0).
------------------

**Структура JSF-приложения**
- JSP или XHTML-страницы, содержащие
  компоненты GUI.
- Библиотеки тегов.
- Управляемые бины.
- Дополнительные объекты (компоненты, конвертеры и валидаторы).
- Дополнительные теги.
- Конфигурация — faces-config.xml (опционально).
- Дескриптор развёртывания — web.xml

------------------
**MVC-модель JSF**
![img.png](img.png)
------------------

**FacesServlet**
- Обрабатывает запросы с браузера.
- Формирует объекты-события и вызывает методы-слушатели.
  ![img_1.png](img_1.png)
------------------

**Cтраницы и компоненты UI**
- Интерфейс строится из компонентов.
- Компоненты расположены на Facelets-шаблонах или страницах JSP.
- Компоненты реализуют интерфейс javax.faces.component.UIComponent.
- Можно создавать собственные компоненты.
- Компоненты на странице объединены в древовидную структуру — представление.
- Корневым элементов представления является экземпляр класса javax.faces.component.UIViewRoot.

**Пример**
```xhtml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:f="http://java.sun.com/jsf/core"
    xmlns:h="http://java.sun.com/jsf/html">
    <h:body>
        <h3>JSF 2.0 + Ajax Hello World Example</h3>
        <h:form>
            <h:inputText id="name"
                value="#{helloBean.name}"></h:inputText>
            <h:commandButton value="Welcome Me">
                <f:ajax execute="name" render="output" />
            </h:commandButton>
        <h2>
        <h:outputText id="output"
            value="#{helloBean.sayWelcome}" />
        </h2>
        </h:form>
    </h:body>
</html>
```

------------------

**Иерархия компонентов**
![img_2.png](img_2.png)

------------------

### 2. JSF: Managed beans:
- Содержат параметры и методы для обработки данных с компонентов.
- Используются для обработки событий UI и валидации данных.
- Жизненным циклом управляет JSF Runtime Envronment.
- Доступ из JSF-страниц осуществляется с помощью элементов EL.
- Конфигурация задаётся в faces-config.xml (JSF 1.X), либо с помощью аннотаций (JSF 2.0).
- Вместо них могут использоваться CDI-бины, EJB или бины Spring.

**Пример:**
```java
package org.itmo.sample;
import javax.faces.bean.ManagedBean;
import javax.faces.bean.SessionScoped;
import java.io.Serializable;

@ManagedBean
@SessionScoped
public class HelloBean implements Serializable {
    
    private static final long serialVersionUID = 1L;
    private String name;

    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getSayWelcome() {
        if("".equals(name) || name == null){ //check if null?
            return "";
        } else {
            return "Ajax message : Welcome " + name;
        }
    }
}
```
------------------

**Контекст (scope) управляемых бинов**
- Задаётся через faces-config.xml или с помощью аннотаций.
-  6 вариантов конфигурации:
- @NoneScoped — контекст не определён, жизненным циклом управляют другие бины.
    - @RequestScoped (применяется по умолчанию) — контекст — запрос.
    - @ViewScoped (JSF 2.0) — контекст — страница.
    - @SessionScoped — контекст — сессия.
    - @ApplicationScoped — контекст — приложение.
    - @CustomScoped (JSF 2.0) — бин сохраняется в Map; программист сам управляет его жизненным циклом

------------------

**Конфигурация управляемых бинов**
1. через faces-config.xml:
   ```xml
   <managed-bean>
       <managed-bean-name>customer</managed-bean-name>
       <managed-bean-class>CustomerBean</managed-beanclass>
       <managed-bean-scope>request</managed-bean-scope>
       <managed-property>
           <property-name>areaCode</property-name>
           <value>#{initParam.defaultAreaCode}</value>
       </managed-property>
   </managed-bean>
   ```
2.  (JSF 2.0) — с помощью аннотаций:
    ```java
    @ManagedBean(name="customer")
    @RequestScoped
    public class CustomerBean {
    ...

    @ManagedProperty(value="#{initParam.defaultAreaCode}
    "
     name="areaCode")
     private String areaCode;
     ...
    }
    ```
------------------
**Доступ к управляемым бинам со страниц приложения**
- Осуществляется с помощью EL-выражений:
    ```html
      ...
    <h:inputText value="#{user.name}"
     validator="#{user.validate}" />
    ...
    <h:inputText binding="#{user.nameField}" />
    ...
    <h:commandButton action="#{user.save}"
     value="Save" />
    ...
    ```
------------------
**CDI-бины**
- Универсальные компоненты уровня бизнес-логики.
- Появились в Java EE 6, копируют концепции, реализованные в Spring.
- Общая идея – «отвязаться» от конкретного фреймворка при создании бизнес-логики внутри приложения.
- В большинстве случаев их можно использовать вместо JSF Managed Beans и EJB.
- По реализации очень похожи на JSF Managed Beans.

Пример:
```java
@Named("bb")
@SessionScoped
public class BookBean { 
    { ... }
}

@Path("/book")
public class BookEndpoint { 
    @Inject 
    private @Named("bb") BookBean bookBean;
    
    @GET 
    public List<Book> getAllBooks() { ... }
}
```
-------------------
**Enterprise Java Beans**
- Компоненты уровня бизнес-логики для «кровавого энтерпрайза».
- Два основных вида – Session Beans и Message-driven Beans.
- Session Beans похожи на JSF Managed Beans и CDIбины, но обеспечивают много дополнительных возможностей.
- Session Beans могут быть «прозрачно» использованы в JSF.
- Message-driven Beans предназначены для асинхронного выполнения задач и в JSF не используются.

Пример Stateless Session Bean:
```java
package converter.ejb;
import java.math.BigDecimal;
import javax.ejb.*;
@Stateless
public class ConverterBean { 
    
    private BigDecimal yenRate = new BigDecimal("83.0602");
    private BigDecimal euroRate = new BigDecimal("0.0093016");
    
    public BigDecimal dollarToYen(BigDecimal dollars) {
        BigDecimal result = dollars.multiply(yenRate);
        return result.setScale(2, BigDecimal.ROUND_UP);
    }
 
    public BigDecimal yenToEuro(BigDecimal yen) {
        BigDecimal result = yen.multiply(euroRate);
        return result.setScale(2, BigDecimal.ROUND_UP);
    }
}
```
----------------------
